rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a multi-tenant, branch-based security model
     * for a microfinance platform. Access to operational data (like borrowers, loans,
     * and payments) is strictly controlled by a user's membership in a specific branch.
     * A global 'admin' role, determined by existence in the `/roles_admin` collection,
     * has overarching read and write permissions for management and oversight.
     *
     * Data Structure:
     * - `/users/{userId}`: Stores private user profiles, including which branches they belong to.
     * - `/branches/{branchId}`: Contains all operational data for a given branch, such as
     *   borrowers, loans, and payments, nested within subcollections.
     * - `/organizations`, `/roles`, `/loanProducts`: Top-level collections for system-wide
     *   configuration data, readable by all authenticated users but only writable by admins.
     * - `/roles_admin/{userId}`: A dedicated collection where the existence of a document
     *   grants a user administrative privileges across the entire system.
     *
     * Key Security Decisions:
     * - Branch-Scoped Access: A user's ability to read or write data within the `/branches/{branchId}`
     *   tree is determined by checking their `branchIds` array stored on their `/users/{userId}` document.
     * - Admin Super-User: An `isAdmin()` function provides a single, clear mechanism for granting
     *   system-wide privileges, simplifying logic for administrative tasks.
     * - User Privacy: Listing users is disallowed to prevent data leakage and user enumeration.
     * - Immutable Logs: Audit logs are append-only. Once created, they cannot be modified or deleted.
     *
     * Denormalization for Authorization: To ensure fast and secure access control, a user's
     * branch memberships (`branchIds`) are denormalized onto their `/users/{userId}` document.
     * This allows rules for branch-specific data to make a single, efficient `get()` call
     * to the user's own profile to verify their permissions, avoiding complex and slow queries.
     *
     * Structural Segregation: The ruleset separates user-centric data (`/users`), operational
     * data (`/branches`), and administrative data (`/roles_admin`) into distinct top-level
     * collections, each with its own clear access control model. This separation ensures
     * that security rules are simple, targeted, and performant.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * Used to verify resource ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Returns true if the document being accessed already exists in Firestore.
     * CRITICAL for all update and delete operations to prevent acting on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Returns true if the user has a document in the '/roles_admin' collection,
     * granting them system-wide administrative privileges.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Returns true if the signed-in user's profile document indicates they are a member
     * of the specified branch. This is the primary function for securing branch-level data.
     * It performs a single `get` request to the user's own document.
     */
    function isMemberOfBranch(branchId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.branchIds.hasAny([branchId]);
    }

    // --------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------

    /**
     * @description Manages organizations. Readable by any authenticated user, but only
     *              admins can create, modify, or delete them.
     * @path        /organizations/{organizationId}
     * @allow       (get, list) for any signed-in user.
     * @deny        (create) for a non-admin user.
     * @principle   Enforces admin-only writes for system-wide configuration data.
     */
    match /organizations/{organizationId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Manages branches within an organization. Branch details can be read by
     *              members of that branch. Only admins can manage the list of branches.
     * @path        /organizations/{organizationId}/branches/{branchId}
     * @allow       (get) for a user who is a member of the branch.
     * @deny        (list) for a non-admin user to prevent leaking organization structure.
     * @principle   Restricts read access to authorized members and write access to admins.
     */
    match /organizations/{organizationId}/branches/{branchId} {
      allow get: if isMemberOfBranch(branchId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Defines system roles. Readable by any authenticated user, but only
     *              admins can create, modify, or delete them.
     * @path        /roles/{roleId}
     * @allow       (get, list) for any signed-in user.
     * @deny        (create, update, delete) for a non-admin user.
     * @principle   Enforces admin-only writes for system-wide configuration data.
     */
    match /roles/{roleId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores user profile data. Users can create and manage their own profile.
     *              Admins have read-only access for administrative purposes.
     * @path        /users/{userId}
     * @allow       (create, update) by user `userId` on their own document.
     * @deny        (list) by anyone, to prevent user enumeration.
     * @principle   Enforces strict document ownership for a user's private data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Stores all borrower data, scoped by branch. Access is restricted
     *              to users who are members of the specified branch.
     * @path        /branches/{branchId}/borrowers/{borrowerId}
     * @allow       (get, create) by a user who is a member of `branchId`.
     * @deny        (update) by a user who is not a member of `branchId`.
     * @principle   Restricts access to data based on branch membership.
     */
    match /branches/{branchId}/borrowers/{borrowerId} {
      allow get, list: if isMemberOfBranch(branchId) || isAdmin();
      allow create: if (isMemberOfBranch(branchId) || isAdmin()) && request.resource.data.branchId == branchId;
      allow update: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc() && request.resource.data.branchId == resource.data.branchId;
      allow delete: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores documents for a specific borrower. Access is inherited from the parent
     *              branch, meaning only members of that branch can view or manage documents.
     * @path        /branches/{branchId}/borrowers/{borrowerId}/documents/{documentId}
     * @allow       (create) a document by a user who is a member of `branchId`.
     * @deny        (get) a document by a user from a different branch.
     * @principle   Inherits security context from the parent resource path.
     */
    match /branches/{branchId}/borrowers/{borrowerId}/documents/{documentId} {
      allow get, list: if isMemberOfBranch(branchId) || isAdmin();
      allow create: if (isMemberOfBranch(branchId) || isAdmin()) && request.resource.data.borrowerId == borrowerId;
      allow update: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc() && request.resource.data.borrowerId == resource.data.borrowerId;
      allow delete: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Defines available loan products. Readable by any authenticated user, but only
     *              admins can create, modify, or delete them.
     * @path        /loanProducts/{loanProductId}
     * @allow       (get, list) for any signed-in user.
     * @deny        (create, update, delete) for a non-admin user.
     * @principle   Enforces admin-only writes for system-wide configuration data.
     */
    match /loanProducts/{loanProductId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores all loan data, scoped by branch. Access is restricted
     *              to users who are members of the specified branch.
     * @path        /branches/{branchId}/loans/{loanId}
     * @allow       (get, create) by a user who is a member of `branchId`.
     * @deny        (update) by a user who is not a member of `branchId`.
     * @principle   Restricts access to data based on branch membership.
     */
    match /branches/{branchId}/loans/{loanId} {
      allow get, list: if isMemberOfBranch(branchId) || isAdmin();
      allow create: if (isMemberOfBranch(branchId) || isAdmin()) && request.resource.data.branchId == branchId;
      allow update: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc() && request.resource.data.branchId == resource.data.branchId;
      allow delete: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores repayment schedules for a loan. Access is inherited from the parent
     *              branch, meaning only members of that branch can view or manage schedules.
     * @path        /branches/{branchId}/loans/{loanId}/repaymentSchedules/{repaymentScheduleId}
     * @allow       (create) a schedule by a user who is a member of `branchId`.
     * @deny        (get) a schedule by a user from a different branch.
     * @principle   Inherits security context from the parent resource path.
     */
    match /branches/{branchId}/loans/{loanId}/repaymentSchedules/{repaymentScheduleId} {
      allow get, list: if isMemberOfBranch(branchId) || isAdmin();
      allow create: if (isMemberOfBranch(branchId) || isAdmin()) && request.resource.data.loanId == loanId;
      allow update: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc() && request.resource.data.loanId == resource.data.loanId;
      allow delete: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores payments for a loan. Access is inherited from the parent
     *              branch. Users can only log payments they collected themselves.
     * @path        /branches/{branchId}/loans/{loanId}/payments/{paymentId}
     * @allow       (create) a payment by a branch member, linking their own UID.
     * @deny        (create) a payment on behalf of another user.
     * @principle   Inherits security context and enforces self-attribution for new data.
     */
    match /branches/{branchId}/loans/{loanId}/payments/{paymentId} {
      allow get, list: if isMemberOfBranch(branchId) || isAdmin();
      allow create: if (isMemberOfBranch(branchId) || isAdmin()) && request.resource.data.loanId == loanId && request.resource.data.branchId == branchId && request.resource.data.collectedByUserId == request.auth.uid;
      allow update: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc() && request.resource.data.loanId == resource.data.loanId && request.resource.data.branchId == resource.data.branchId && request.resource.data.collectedByUserId == resource.data.collectedByUserId;
      allow delete: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Stores payment allocations. Access is inherited from the parent
     *              branch, meaning only members of that branch can manage allocations.
     * @path        /branches/{branchId}/loans/{loanId}/payments/{paymentId}/paymentAllocations/{paymentAllocationId}
     * @allow       (create) an allocation by a user who is a member of `branchId`.
     * @deny        (get) an allocation by a user from a different branch.
     * @principle   Inherits security context from the parent resource path.
     */
    match /branches/{branchId}/loans/{loanId}/payments/{paymentId}/paymentAllocations/{paymentAllocationId} {
      allow get, list: if isMemberOfBranch(branchId) || isAdmin();
      allow create: if (isMemberOfBranch(branchId) || isAdmin()) && request.resource.data.paymentId == paymentId;
      allow update: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc() && request.resource.data.paymentId == resource.data.paymentId;
      allow delete: if (isMemberOfBranch(branchId) || isAdmin()) && isExistingDoc();
    }

    /**
     * @description Defines system permissions. Readable by any authenticated user, but only
     *              admins can create, modify, or delete them.
     * @path        /permissions/{permissionId}
     * @allow       (get, list) for any signed-in user.
     * @deny        (create, update, delete) for a non-admin user.
     * @principle   Enforces admin-only writes for system-wide configuration data.
     */
    match /permissions/{permissionId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores immutable audit log entries. Branch members can create logs for
     *              their branch, but only admins can read them. Logs cannot be changed.
     * @path        /auditLogs/{auditLogId}
     * @allow       (create) by a user who is a member of the branch specified in the log data.
     * @deny        (update, delete) by anyone to ensure immutability.
     * @principle   Provides secure, append-only logging with restricted read access.
     */
    match /auditLogs/{auditLogId} {
      allow get, list: if isAdmin();
      allow create: if isSignedIn() && isMemberOfBranch(request.resource.data.branchId) && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages admin role assignments. Existence of a document in this collection
     *              grants a user admin privileges. Only other admins can manage this list.
     * @path        /roles_admin/{userId}
     * @allow       (get, list, create, update, delete) only for existing admins.
     * @deny        (get) for a non-admin user.
     * @principle   Secures the mechanism for granting and revoking administrative roles.
     */
    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

  }
}